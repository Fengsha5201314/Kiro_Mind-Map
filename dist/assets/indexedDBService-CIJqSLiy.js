var t=Object.defineProperty,e=(e,a,n)=>((e,a,n)=>a in e?t(e,a,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[a]=n)(e,"symbol"!=typeof a?a+"":a,n);const a={dbName:"MindMapDB",version:1,stores:{mindmaps:{keyPath:"id",indexes:[{name:"createdAt",keyPath:"createdAt",unique:!1},{name:"updatedAt",keyPath:"updatedAt",unique:!1},{name:"title",keyPath:"data.title",unique:!1}]}}};class n extends Error{constructor(t,e,a){super(t),this.code=e,this.details=a,this.name="IndexedDBServiceError"}}class r{constructor(){e(this,"db",null),e(this,"initPromise",null)}async initDatabase(){if(!this.db)return this.initPromise||(this.initPromise=new Promise((t,e)=>{if(!window.indexedDB)return void e(new n("浏览器不支持IndexedDB","INDEXEDDB_UNSUPPORTED"));const r=indexedDB.open(a.dbName,a.version);r.onerror=()=>{e(new n("IndexedDB打开失败","DATABASE_OPEN_FAILED",r.error))},r.onsuccess=()=>{this.db=r.result,this.db.onclose=()=>{this.db=null,this.initPromise=null},this.db.onversionchange=()=>{this.db?.close(),this.db=null,this.initPromise=null},t()},r.onupgradeneeded=t=>{const r=t.target.result;try{if(!r.objectStoreNames.contains("mindmaps")){const t=r.createObjectStore("mindmaps",{keyPath:a.stores.mindmaps.keyPath});a.stores.mindmaps.indexes.forEach(e=>{t.createIndex(e.name,e.keyPath,{unique:e.unique})})}}catch(i){e(new n("数据库结构创建失败","DATABASE_UPGRADE_FAILED",i))}},r.onblocked=()=>{e(new n("数据库被阻塞，请关闭其他标签页","DATABASE_BLOCKED"))}})),this.initPromise}async getDatabase(){if(await this.initDatabase(),!this.db)throw new n("数据库连接失败","DATABASE_CONNECTION_FAILED");return this.db}async executeTransaction(t,e,a){const r=await this.getDatabase();return new Promise((i,s)=>{try{const o=r.transaction([t],e),c=o.objectStore(t),d=a(c);d.onsuccess=()=>{i(d.result)},d.onerror=()=>{s(new n("事务操作失败","TRANSACTION_FAILED",d.error))},o.onerror=()=>{s(new n("事务失败","TRANSACTION_FAILED",o.error))},o.onabort=()=>{s(new n("事务被中止","TRANSACTION_ABORTED",o.error))}}catch(o){s(new n("事务创建失败","TRANSACTION_CREATE_FAILED",o))}})}calculateDataSize(t){try{return new Blob([JSON.stringify(t)]).size}catch{return 0}}async saveMindMap(t){try{const e=Date.now(),a={id:t.id,data:{...t,updatedAt:e},createdAt:t.createdAt||e,updatedAt:e,size:this.calculateDataSize(t)};await this.executeTransaction("mindmaps","readwrite",t=>t.put(a))}catch(e){if(e instanceof n)throw e;throw new n("思维导图保存失败","SAVE_FAILED",e)}}async getMindMap(t){try{const e=await this.executeTransaction("mindmaps","readonly",e=>e.get(t));return e?e.data:null}catch(e){if(e instanceof n)throw e;throw new n("思维导图读取失败","READ_FAILED",e)}}async getAllMindMaps(){try{return(await this.executeTransaction("mindmaps","readonly",t=>t.getAll())).sort((t,e)=>e.updatedAt-t.updatedAt).map(t=>t.data)}catch(t){if(t instanceof n)throw t;throw new n("思维导图列表读取失败","READ_ALL_FAILED",t)}}async getMindMapsPaginated(t=0,e=20){try{const a=await this.getDatabase();return new Promise((r,i)=>{const s=a.transaction(["mindmaps"],"readonly").objectStore("mindmaps"),o=s.index("updatedAt"),c=s.count(),d=o.openCursor(null,"prev");let h=0;const l=[];let A=0,u=0;c.onsuccess=()=>{h=c.result},d.onsuccess=a=>{const n=a.target.result;if(n){if(A>=t&&u<e){const t=n.value;l.push(t.data),u++}A++,u<e?n.continue():r({data:l,total:h,hasMore:t+e<h})}else r({data:l,total:h,hasMore:t+e<h})},d.onerror=()=>{i(new n("分页查询失败","PAGINATED_READ_FAILED",d.error))},c.onerror=()=>{i(new n("计数查询失败","COUNT_FAILED",c.error))}})}catch(a){if(a instanceof n)throw a;throw new n("分页查询失败","PAGINATED_READ_FAILED",a)}}async searchMindMaps(t){try{const e=await this.getAllMindMaps(),a=t.toLowerCase();return e.filter(t=>!!t.title.toLowerCase().includes(a)||t.nodes.some(t=>t.content.toLowerCase().includes(a)))}catch(e){if(e instanceof n)throw e;throw new n("搜索失败","SEARCH_FAILED",e)}}async deleteMindMap(t){try{await this.executeTransaction("mindmaps","readwrite",e=>e.delete(t))}catch(e){if(e instanceof n)throw e;throw new n("思维导图删除失败","DELETE_FAILED",e)}}async deleteMindMaps(t){try{const e=await this.getDatabase();return new Promise((a,r)=>{const i=e.transaction(["mindmaps"],"readwrite"),s=i.objectStore("mindmaps");let o=0;const c=t.length;if(0===c)return void a();const d=()=>{o++,o===c&&a()};t.forEach(t=>{const e=s.delete(t);e.onsuccess=d,e.onerror=()=>{r(new n(`删除思维导图 ${t} 失败`,"BATCH_DELETE_FAILED",e.error))}}),i.onerror=()=>{r(new n("批量删除事务失败","BATCH_DELETE_TRANSACTION_FAILED",i.error))}})}catch(e){if(e instanceof n)throw e;throw new n("批量删除失败","BATCH_DELETE_FAILED",e)}}async clearAll(){try{await this.executeTransaction("mindmaps","readwrite",t=>t.clear())}catch(t){if(t instanceof n)throw t;throw new n("清空数据失败","CLEAR_FAILED",t)}}async getStorageInfo(){try{const t=await this.executeTransaction("mindmaps","readonly",t=>t.getAll());let e,a=0;t.forEach(t=>{a+=t.size,(!e||t.createdAt<e.createdAt)&&(e={id:t.id,title:t.data.title,createdAt:t.createdAt})});const n=52428800;return{totalSize:a,availableSize:Math.max(0,n-a),mindMapCount:t.length,oldestMindMap:e}}catch(t){if(t instanceof n)throw t;throw new n("获取存储信息失败","STORAGE_INFO_FAILED",t)}}async exportAllData(){try{return{mindmaps:await this.getAllMindMaps(),exportTime:Date.now(),version:"1.0"}}catch(t){if(t instanceof n)throw t;throw new n("数据导出失败","EXPORT_FAILED",t)}}async importData(t){try{const a={imported:0,skipped:0,errors:[]};for(const n of t.mindmaps)try{if(await this.getMindMap(n.id)){a.skipped++;continue}await this.saveMindMap(n),a.imported++}catch(e){a.errors.push(`导入思维导图 ${n.title} 失败: ${e}`)}return a}catch(e){if(e instanceof n)throw e;throw new n("数据导入失败","IMPORT_FAILED",e)}}async close(){this.db&&(this.db.close(),this.db=null,this.initPromise=null)}async isAvailable(){try{return await this.initDatabase(),!0}catch{return!1}}}export{r as IndexedDBService,n as IndexedDBServiceError};
